Задачи на 2-й семестр по курсу ООП

1. Знакомство с устройством MDI приложения на Java
==================================================
В предоставленном комплекте исходником уже реализован некоторый функционал 
MDI приложения (главное окно, меню, окно протокола, окно моделирования 
движения робота). Требуется разобраться со следующими моментами:
- как запускается приложение
- как создаются окна
- как инициализируется меню
- как подключаются обработчики событий

Задания:
- Выполнить задание из JavaDoc класса MainApplicationFrame:
"Метод создания меню перегружен функционалом и трудно читается. Следует разделить его на серию более простых методов (или вообще выделить отдельный класс)"
- требуется добавить пункт меню, позвлояющий закрыть приложение
- требуется собрать обработку события выхода из приложения в один метод
и сделать так, чтобы в этом методе выдавался запрос на подтверждение 
выхода (см. класс JOptionPane)

Дополнительное задание (обязательно для группы extra):
- сделать так, чтобы диалог на основе JOptionPane выдавал текст на кнопках 
на русском языке.


Методические указания по задаче 1.
==================================

Добавление пункта меню делается просто копированием уже имеющегося кода.
При изменении кода построения меню следует обратить внимание студента на
то, что в исходном состоянии код неудобен для работы. А именно, уместно
выделить код построения выпадающих меню в отдельные методы.

При добавлении нового пункта меню потребуется какой-то метод для обработки
события. Нужно будет добавить этот метод (в класс MainApplicationFrame).
Затем нужно сообразить, как закрыть приложение. Есть два подхода. В любом
случае стоит посмотреть точки использования константы JFrame.EXIT_ON_CLOSE
управляющей поведением JFrame при возникновении события закрытия окна
(WindowEvent.WINDOW_CLOSING). Соответственно, в обработчике события либо
можно повторить вызов System.exit(0) (это будет соответствовать
стандартной реакции на событие закрытия, но нарушает идеологию выполнения
действий через события; в частности, другие компоненты не узнают о том,
что программа завершается, поскольку не получат события
WindowEvent.WINDOW_CLOSING), либо (что в некотором смысле правильнее)
синтезировать посылку события WindowEvent.WINDOW_CLOSING, чтобы
сработал стандартный обработчик. В этих случаях пункт меню уже будет
работать.

Вот пример кода, который формирует событие на закрытие
приложения:

JMenuItem exitItem = new JMenuItem("Выход", KeyEvent.VK_X | KeyEvent.VK_ALT);
exitItem.addActionListener((event) -> {
    Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(
        new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
});

Собственно, тут важно:
1. Разобраться, какое событие отвечает за закрытие
2. Сообразить, как добраться до очереди событий
3. Как сформировать правильное событие

Для того, чтобы среагировать на закрытие приложение следует перехватить
соответсвующее событие. Это делается путем регистрации слушателя
WindowListener (проще использовать заготовку в виде WindowAdapter) в
главном окне приложения (см. метод addWindowListener). Для перехвата
события закрытия нужен метод WindowListener.windowClosing.

Затем для выдачи стандартных диалогов подтверждения действия следует
использовать класс JOptionPane. В этом классе есть набор статических
методов, позволяющих отображать все стандартные диалоги подтверждения.
Наблюдение: по умолчанию этот класс будет выдавать текст на кнопках не на
русском языке. Правильная локализация - это отдельная задача для сильных
студентов.

Также потребуется сообразить, что нужно отключить действие при закрытии
приложения, настроенное по умолчанию. Делается это вызовом:
setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);



2. Знакомство с управлением разнородными объектами
==================================================
Обычно считается хорошим тоном, когда приложение запоминает свое состояние 
на момент выхода, чтобы можно было продолжить работу с ним без 
дополнительной настройки при последующем запуске.

Задания:
- в методе выхода из приложения нужно сохранить (в файл) следующие свойства: 
положение на экране, ширина, высота, свёрнутое/развернутое состояние.
- при запуске приложения следует восстановить геометрию окошек приложения: 
положение на экране, ширина, высота, свёрнутое/развернутое состояние
- в архитектуре нужно учесть, что все окна добавленные в следующих задачах должны тоже уметь сохранять своё состояние

Файл с конфигурацией следует создавать в домашнем каталоге пользователя в директории с названием в виде вашей фамилии.
Например ${home}/ivanov/state.cfg
Для хранения информации в файле можете использовать любой формат, даже просто строковый. 



Методические указания по задаче 2.
==================================

Это задание направлено на отработку следующих навыков.

- наделение разных классов некоторым общим поведением (способность 
сохранять и восстанавливать состояние)

- введение абстракций данных (некоторая общая модель для сохранения 
состояния окна)

Прежде всего, нужно заметить, что в приложении два окна, реализованных как 
независимые классы без общего предка. То есть просто так ввести общее 
умение сохраняться негде (да, в принципе есть вариант введения общего 
предка, но это очень неудобно и неправильно с точки зрения организации 
приложения, поскольку приложение может содержать окна, не обязательно 
наследуемые от JInternalFrame, то есть способность к сохранению не должна  
быть привязана именно к этому типу). Значит, требуется интерфейс с 
методами "сохранить состояние" и "восстановить состояние".

Следующий вопрос: куда это самое состояние сохранять. Понятно, что эти 
методы не должны работать напрямую с файлом, поскольку конкретный 
компонент не имеет права знать о том, как глобально устроен механизм 
сохранения настроек. Значит, нужна некоторая абстракция данных, в рамках 
которой компонент сможет построить отчуждаемое представление состояния (по 
сути, произвести маршаллинг данных своего состояния). Тут подходы могут 
быть разными. Мне наиболее простой кажется подход, когда состояние 
сохраняется в словарь (Map<String, String>). Тогда каждая компонента 
составляет свой словарь. А затем отдельные словари можно собрать в один 
общий путем приписывания префиксов к ключам отдельных словарей.

Например: 
окно протокола формирует словарь:
width -> 100
height -> 200
и окно для моделирования движения робота формирует словарь:
width -> 300
height -> 400
Тогда мы собираем всю эту информацию в один общий словарь:
log.width -> 100
log.height -> 200
model.width -> 300
model.height -> 400

При таком подходе код достаточно удачно распадается на следующие 
компоненты:
- код записи словаря в файл и чтения словаря из файла
- код формирования подсловаря по общему словарю (фильтрация по префиксу ключа ) и 
код добавления подсловаря к словарю (приписывание префикса ключа)
- код формирования словарей отдельных компонент

Работу с подсловарями можно организовать как отдельный класс, который 
строится по исходному словарю и префиксу ключей. То есть реализуем класс 
на основе шаблона "Фильтр" (его студенты уже знают), за основу берем 
классы AbstractMap и AbstractSet (просто смотрим, какие методы нужно 
доопределить или переопределить). 

Код формирования словаря состояния отдельных компонент можно также собрать 
в общий класс, к методам которого отдельные компоненты будут обращаться 
для формирования своего состояния.

Важное замечание. Может возникнуть соблазн воспользоваться тем свойством, 
что все графические компоненты в Java являются сериализуемыми. Но это 
плохая идея (попытка использовать сериализацию завершится неуспехом, и это 
правильно). Графические компоненты являются сериализуемыми лишь по 
историческим причинам. 

Именно поэтому правильное решение этой задачи основано на идее, похожей на 
сериализацию (отдельный интерфейс для описания этого свойства), но с 
отдельной реализацией, которую мы сами контролируем.


3. Реализация идеи MVC
==================================

- реализовать новое окно (например, на основе диалоговых компонент), в
котором будут отображаться текущие координаты робота
- для этого придется разделить логику отображения робота
(визуализацию) и модель робота (код получения координат и
моделирования движения)
- модель должна уметь оповестить слушателей об обновлении через поле PropertyChangeSupport,
чтобы затем окно могло подписаться на уведомления от модели через addPropertyChangeListener(PropertyChangeListener listener)
и перерисовать модель.
- Обратите внимание, что GameVisualizer тоже должен подписаться на изменение модели, т.к. рисует модель
- с использованием этого нового окна и/или окна протоколирования нужно
исправить ошибку в логике управления роботом (сейчас при определенном
взаимном расположении робота и целевой точки робот уходит в
противоположном направлении)
- состояние этого окна тоже должно сохраняться (подерживаем функционал предыдущей задачи)

По сути эта задача предполагает использование того материала, который
мы рассмотрели на лекциях. Ну и продолжаем проявлять ситуации, в
которых необходим рефакторинг.

==================================


Задача №4

1. Класс LogWindowSource порождает утечку ресурсов (связанные слушатели оказываются удерживаемыми в памяти).
Нужно решить проблему утечки ресурсов. Требуется исправить утечку памяти.
2. Придумать и реализовать структуру данных для хранения записей, 
отображаемых в окне протоколирования. В исходной версии кода в качестве 
такой структуры использован ArrayList без какой-либо самоочистки. В 
реальности же обычно требуется, чтобы размер хранимой (и отображаемой в  
окне) части протокола был ограничен. Но если просто удалять из ArrayList 
старые записи, это приведет к неэффективной реализации (добавление записи 
будет работать за O(N), поскольку придется удалять устаревшие записи из 
начала структуры) и к проблемам с конкурентным доступом (возникает 
состояние гонки между добавлением данных и итерированием существующих).

Структура для хранения протокола должна обладать 
следующими свойствами:

- имела ограниченный размер (старые записи вытесняются)
- должна быть потокобезопасной (запись и чтение порождают состояние гонки)
- должна быть возможность доступа к части данных (сегмент смежных записей) 
по индексам начала и конца (такая операция, по идее, нужна для 
эффективного отображения данных в окне, чтобы не читать полный лог) 

- добавление данных (с потенциальным удалением старых) и чтение уже 
хранящихся должны быть быстрыми (т.е. никаких O(n)) 
- должна возвращать потокобезопасный итератор (то есть добавление данных 
во время итерирования не должно разрушать итератор) 

Первые 3 пункта могут быть реализованы на любой структуре (стэк, очередь, 
массив), но потребуется сделать структуру потокобезопасной (конкурентные 
чтение и запись).

Последние 2 пункта - усложненная версия задачи, позволяющая 
познакомиться, например, с темпоральными структурами данных.

Для удобства демонстрации вашего решения сделайте следующее:
- Уменьшите размер коллекции до 5 записей
- Сделайте как минимум 2 способа добавить разные сообщения в лог. Например:
   - Ещё одна кнопка меню с сообщением в лог
   - Сообщение в лог при изменении точки движения робота (с указанием нажатой пользователем координаты)


==================================


Задача №5

Сделать так, чтобы приложение было локализовано (то есть обеспечить 
возможность выбора языка, на котором работает пользовательский интерфейс).
Для упрощения задачи можно сделать следующие допущения:
- локализацию проводим только для собственных компонент программы 
(сообщения в готовых диалогах Swing переводить не нужно);
- считаем, что должны поддерживаться два языка: русский и английский.
Если с английским возникают какие-то сложности, хотя их быть не должно, то можно использовать транслит (русский язык, выводимый латинницей)
- Выбранная локаль тоже должна сохраняться при выходе из приложения (поддерживаем функциональность сохранения состояния)

Для решения задачи следует разобраться с работой классов ResourceBundle и 
с тем, как формировать сообщения через форматирование.

Усложнение задачи (обязательно для группы extra):
Ускорить форматирование сообщений за счет использования кэша. Здесь важно 
разобраться с тем, что Java предоставляет два механизма для шаблонизации: 
на основе класса MessageFormat, и на основе класса Formatter. В случае с 
классом MessageFormat можно заметить, что вызов MessageFormat.format 
сводится к запуску парсера (создает объект MessageFormat), который потом 
используется для форматирования. Так вот в кэше можно сохранять эти самые 
созданные объекты MessageFormat, и тогда форматирование будет работать 
существенно быстрее (парсер работает дольше, чем код форматирования). В 
случае с классом Formatter такая техника, увы, не работает.
Поэтому для выполнения этого задания обязательно нужно использовать MessageFormat.

Если вы используете properties файлы, например для локализации приложения, то часто в них используется кодировка ISO-8859-1, и русские символы отображаются в закодированном виде, например "\u041A\u043E\u043D\u0442\u0430\u043A\u0442".
Чтобы среда разработки их сама кодировала и декодировала, есть опция "Transparent native-to-ascii conversation" (Settings -> File Encodings). Включите её и станет намного удобнее работать с properties файлами.

==================================

Задача №6

Сделать так, чтобы можно было загружать "роботов" извне. А именно, добавить возможность выбрать файл .jar, в котором были бы собраны классы 
(файлы с байт-кодом), содержащие логику работы робота (например, робот может двигаться быстрее, но меньше угол поворота) и правила его визуализации (например, робот  может быть 4-колесным и другого цвета). 
Все добавленные компоненты должны быть локализованы (поддерживаем функциональность предыдущих задач)

Задача направлена на то, чтобы дать возможность поработать с загрузчиками 
классов. При загрузке файла следует убедиться, что это именно jar-архив, а 
затем создать URLClassLoader, чтобы загрузить необходимые классы.

==================================


Идеи для дополнительной задачи:

И на базе моделирования движения робота возникает серия задач:

- бой роботов, когда один из них управляется по сети из другой программы 
(отрабатываем сетевое взаимодействие) 

- роботы автономны, но программа позволяет загрузить логику работы робота 
из внешнего файла (class-файл с реализацией некоторого интерфейса) (тут 
отрабатываем использование загрузчиков классов и динамическое связывание) 

- навигаця роботов (объезд препятствий), причем можно вводить сложности из реальной жизни (скольжение, инерцию и т.п.), управление с задержкой (т.е. когда присутствует латентность между получением телеметрии от робота и исполнением сформированной команды)

- сетевое взаимодействие (несколько роботов на одном экране, могут, например, как-то взаимодействовать, стрелять или толкаться, и управление дополнительными роботами должно быть с удаленного клиента)

- кооперативная многозадачность (если есть несколько роботов, надо давать им возможность поработать, причем кванты времени должны по возможности быть честными, т.е. разные роботы должны получать равные по времени кванты; код должен быть устойчивым к падениям в коде конкретного робота)

- что-то своё (Необходимо согласовать!!!)
